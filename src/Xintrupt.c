/*!	\file Xintrupt.c
	\brief Initializing function for External Interrupts
	
Includes global variables, function main with initializations and most important software interrupts and threads

\verbatim
*********************************************************************
* File: Xintrupt.c
* Devices: TMS320F28XXX
* Author: Alvaro Garcia
* History:
*   26/07/2007 - original (based on DSP281x header files v1.00, D. Alter)
*********************************************************************
\endverbatim
*/

#include "DSP2833x_Device.h"

#include "amc.h"

/*! variable to write on the XINTnCR register of the external interrupt
 *  configured in configureXint function */
volatile Uint16 *xint_register;

/******************************************************************************/
/*!
 * \brief Function to initialize external interrupts.
 * GPIOs from 50 to 53 are external interrupts from 3 to 6.
 * Interrupts for hall sensors ( 3 to 5 ) detect both edges.
 * Interrupt for safety ( 6 ) configured for falling edge.
 */
/******************************************************************************/
void InitXintrupt(void)
{
	/* XINT3,4,5,6 are GPIO50,51,52,53 */
	EALLOW;
	GpioIntRegs.GPIOXINT3SEL.bit.GPIOSEL = 18;
	GpioIntRegs.GPIOXINT4SEL.bit.GPIOSEL = 19;
	GpioIntRegs.GPIOXINT5SEL.bit.GPIOSEL = 20;
	GpioIntRegs.GPIOXINT6SEL.bit.GPIOSEL = 21;
	EDIS;
	

/*** Configure the Interrupt 1 to be generated by a rising edge (low-to-high transition) but keeping it disable ***/
	XIntruptRegs.XINT1CR.bit.ENABLE = 0;		// disable
	XIntruptRegs.XINT1CR.bit.POLARITY = 0;		// negative triggered because of the hardware inversion of the signal
	
/*** Configure the Interrupt 2 to be generated by a falling edge (high-to-low transition) but keeping it disable ***/
	XIntruptRegs.XINT2CR.bit.ENABLE = 0;		// disable
	XIntruptRegs.XINT2CR.bit.POLARITY = 1;		// positive triggered because of the hardware inversion of the signal
	
	XIntruptRegs.XINT3CR.bit.ENABLE = 1;        // Enable XINT3 (HALL 1)
	XIntruptRegs.XINT3CR.bit.POLARITY = 3;      // Both edges interrupt
	
	XIntruptRegs.XINT4CR.bit.ENABLE = 1;        // Enable XINT4 (HALL 2)
	XIntruptRegs.XINT4CR.bit.POLARITY = 3;      // Both edges interrupt
	
	XIntruptRegs.XINT5CR.bit.ENABLE = 1;        // Enable XINT5 (HALL 3)
	XIntruptRegs.XINT5CR.bit.POLARITY = 3;      // Both edges interrupt
	
	XIntruptRegs.XINT6CR.bit.ENABLE = 1;        // Enable XINT6 (SAFETY)
	XIntruptRegs.XINT6CR.bit.POLARITY = 0;      // Fallin edge interrupt 
	
/*** Enable the XINT interrupts ***/
	PieCtrlRegs.PIEIER12.bit.INTx1 = 1;	// Enable XINT3 in PIE group 12
	PieCtrlRegs.PIEIER12.bit.INTx2 = 1;	// Enable XINT4 in PIE group 12
	PieCtrlRegs.PIEIER12.bit.INTx3 = 1;	// Enable XINT5 in PIE group 12
	PieCtrlRegs.PIEIER12.bit.INTx4 = 1;	// Enable XINT6 in PIE group 12

   IER |= M_INT12;                             // Enable CPU int12

} /* end InitXintrupt() */

/*!
 * \brief Function to select the external interrupt of I1, I2, I3, I4
 * Only one of the inputs can be selected as external interrupt. If one of these
 * is enabled, the others are disabled.
 * \param [in] input Number of input to configure external interrupt.
 * ****************************************************************************/
void configureXint( UNS8 input )
{
	switch( input )
	{
		case 1:
			GpioIntRegs.GPIOXINT1SEL.bit.GPIOSEL = 22; // GPIO22
			break;
		case 2:
			GpioIntRegs.GPIOXINT1SEL.bit.GPIOSEL = 27; // GPIO27
			break;
		case 3:
			GpioIntRegs.GPIOXINT7SEL.bit.GPIOSEL = 3;  // GPIO35
			break;
		case 4:
			GpioIntRegs.GPIOXINT7SEL.bit.GPIOSEL = 4;  // GPIO36
			break;
		default:
			break;
	}
	if( (input == 1) || (input == 2) )
	{
		XIntruptRegs.XINT7CR.bit.ENABLE   = 0;	// disable
		PieCtrlRegs.PIEIER12.bit.INTx5    = 0;	// Disable XINT7 in PIE group 12
		XIntruptRegs.XINT1CR.bit.ENABLE   = 1;	// enable
		XIntruptRegs.XINT1CR.bit.POLARITY = 0;		
		PieCtrlRegs.PIEIER1.bit.INTx4     = 1;	// Enable XINT1 in PIE group 1
		xint_register = &( XIntruptRegs.XINT1CR.all );
		IER |= M_INT1;                             // Enable CPU int1
	}
	if( (input == 3) || (input == 4) )
	{
		XIntruptRegs.XINT1CR.bit.ENABLE   = 0;	// disable
		PieCtrlRegs.PIEIER1.bit.INTx4     = 0;	// Disable XINT1 in PIE group 1
		XIntruptRegs.XINT7CR.bit.ENABLE   = 1;	// enable
		XIntruptRegs.XINT7CR.bit.POLARITY = 0;		
		PieCtrlRegs.PIEIER12.bit.INTx5    = 1;	// Enable XINT7 in PIE group 12
		xint_register = &( XIntruptRegs.XINT7CR.all );
		IER |= M_INT12;                             // Enable CPU int12
	}
}


/*** end of file *****************************************************/
